# 理解动静结合的路由管理

1. 动态路由 指的是不同角色的用户登录进来看到的路由是不一样的
2. 静态路由 指的是不同角色的用户登录进来看到的是一样的
3. asyncRoutes + constantRoutes = routes

# 菜单生成逻辑

1. this.$router.options.routes 路由自带的默认属性 获取的就是初始化完成时传给routes选型的数组
静态的 确定下来不能修改 也不是响应式的

2. 通过v-for遍历生成 所以只要routes里面有内容 左侧就有内容 且顺序保持一致

3. 路由配置项 hidden 决定当前是否显示到左侧菜单 meta:{title,icon}

# Layout路由

1. hack方案 每个路由都是先走一遍layout，然后渲染二级路由 目的是为了有这个架子
2. 当children属性中 子路由的path置空，那么它将作为默认渲染的二级路由
   访问一级路由的路径的时候在一级路由对应的组件渲染出来之后 在二级路由的出口位置 还可以继续渲染它默认二级路由

# 组织架构

1. 渲染数据的一般模式

  声明响应式数据 -> 单独来一个method[调用接口] -> created/mounted调用这个函数

2. 如何使用组件
  
  看文档 找到demo 最小化渲染出来  根据自己的业务改demo 
  任何想要定制组件的需求 只要是常见的 通常都有对应prop来进行配置  [展开子节点 识别字段名]


3. 树形数据处理
  
  前端常见问题  后端返回的数据和组件需要的数据格式不统一  数据转化
              组件产出的数据和接口要求的数据格式不统一  数据转化

  对于常见的数组方法  forEach 、map、filter 
  常见的对象方法   Object.keys(obj) Object.values(obj) 


4. 实际开发时的姿势
  碰到需求 优先引擎搜索 相似的答案 稍微做一点修改 [基础的原理知道 正确修改]


5. 串行和并行接口请求
  1. 串行   一个等待另一个  常见于后者对于前者有依赖  await
  2. 并行   各自完成各自的  常见于加快数据的返回    Promise.all([promise1,promise2]).then(res=> res是一个返回值组成的数组)

